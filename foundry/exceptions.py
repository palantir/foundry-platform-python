#  Copyright 2024 Palantir Technologies, Inc.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""
    Palantir OpenAPI

    The Palantir REST API. Please see https://www.palantir.com/docs for more details.

    The version of the OpenAPI document: 1.738.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import functools
import json
from typing import Any
from typing import Callable
from typing import Dict
from typing import Optional
from typing import TypeVar
import sys
from urllib3._collections import HTTPHeaderDict
from foundry.versions import __version__
from foundry.versions import __openapi_document_version__
from foundry.versions import __openapi_specification_version__
from foundry.versions import __openapi_generator_version__
from pydantic import __version__ as __pydantic__version__
from pydantic_core import __version__ as __pydantic_core__version__
from pydantic import ValidationError


class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class SDKInternalError(Exception):
    def __init__(self, msg: str) -> None:
        self.msg = msg

    def __str__(self):
        message = self.msg

        sys_version = sys.version.replace("\n", " ")
        message += (
            "\n\nThis is an unexpected issue and should be reported. "
            "When filing an issue, make sure to copy the package information "
            "listed below.\n\n"
            f"OS: {sys.platform}\n"
            f"Python Version: {sys_version}\n"
            f"SDK Version: {__version__}\n"
            f"OpenAPI Document Version: {__openapi_document_version__}\n"
            f"OpenAPI Specification Version: {__openapi_specification_version__}\n"
            f"OpenAPI Generator Version: {__openapi_generator_version__}\n"
            f"Pydantic Version: {__pydantic__version__}\n"
            f"Pydantic Core Version: {__pydantic_core__version__}\n"
        )

        return message


AnyCallableT = TypeVar("AnyCallableT", bound=Callable[..., Any])


def handle_unexpected(
    __func: AnyCallableT,
) -> AnyCallableT:
    @functools.wraps(__func)
    def validate(*args, **kwargs):
        try:
            return __func(*args, **kwargs)
        except (OpenApiException, ValidationError) as e:
            # pass through these exceptions
            raise e
        except Exception as e:
            raise SDKInternalError(str(e)) from e

    return validate  # type: ignore


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):
    status: int
    reason: Optional[str]
    body: Optional[str]
    headers: HTTPHeaderDict
    json: dict
    error_code: str
    error_name: str
    error_instance_id: str
    parameters: Dict[str, Any]

    def __init__(
        self,
        http_resp: Urllib3Response,
    ) -> None:
        self.status = http_resp.status
        self.reason = http_resp.reason
        self.body = http_resp.data.decode("utf-8")
        self.headers = http_resp.headers
        try:
            self.json = json.loads(self.body or "")
        except Exception as e:
            raise SDKInternalError(f"Unable to parse error body: {self.body}")

        try:
            self.error_code = self.json["errorCode"]
            self.error_name = self.json["errorName"]
            self.error_instance_id = self.json["errorInstanceId"]
            self.parameters = self.json["parameters"]
        except KeyError as e:
            raise SDKInternalError(f"Unable to fetch error information: {e}")

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\n" "Reason: {1}\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\n".format(self.headers)

        if self.body:
            error_message += "HTTP response body: {0}\n".format(self.body)

        return error_message


class BadRequestException(ApiException):
    pass


class NotFoundException(ApiException):
    pass


class UnauthorizedException(ApiException):
    pass


class ForbiddenException(ApiException):
    pass


class ServiceException(ApiException):
    pass


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result


# Delayed import since the rest module imports exceptions from the module
from foundry.rest import RESTResponse
from foundry.rest import Urllib3Response

#  Copyright 2024 Palantir Technologies, Inc.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""
    Palantir OpenAPI

    The Palantir REST API. Please see https://www.palantir.com/docs for more details.

    The version of the OpenAPI document: 1.738.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from pydantic import Field
from typing_extensions import Annotated
from pydantic import StrictBool, StrictBytes, StrictInt, StrictStr

from typing import Any, Dict, List, Optional, Union

from foundry.models.branch import Branch
from foundry.models.create_branch_request import CreateBranchRequest
from foundry.models.create_dataset_request import CreateDatasetRequest
from foundry.models.create_transaction_request import CreateTransactionRequest
from foundry.models.dataset import Dataset
from foundry.models.file import File
from foundry.models.list_branches_response import ListBranchesResponse
from foundry.models.list_files_response import ListFilesResponse
from foundry.models.table_export_format import TableExportFormat
from foundry.models.transaction import Transaction
from foundry.models.transaction_type import TransactionType

from foundry.api_client import ApiClient
from foundry.exceptions import handle_unexpected


class DatasetsApiServiceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: ApiClient) -> None:
        self._api_client = api_client

    @validate_call
    @handle_unexpected
    def abort_transaction(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset that contains the Transaction.")],
        transaction_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Transaction.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Transaction:
        """abort_transaction

        Aborts an open Transaction. File modifications made on this Transaction are not preserved and the Branch is not updated.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-write`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset that contains the Transaction. (required)
        :type dataset_rid: str
        :param transaction_rid: The Resource Identifier (RID) of the Transaction. (required)
        :type transaction_rid: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        if transaction_rid is not None:
            _path_params['transactionRid'] = transaction_rid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transaction"
            
        }
        response_data = self._api_client.call_api(
            method='POST',
            resource_path='/v1/datasets/{datasetRid}/transactions/{transactionRid}/abort',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def commit_transaction(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset that contains the Transaction.")],
        transaction_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Transaction.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Transaction:
        """commit_transaction

        Commits an open Transaction. File modifications made on this Transaction are preserved and the Branch is updated to point to the Transaction.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-write`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset that contains the Transaction. (required)
        :type dataset_rid: str
        :param transaction_rid: The Resource Identifier (RID) of the Transaction. (required)
        :type transaction_rid: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        if transaction_rid is not None:
            _path_params['transactionRid'] = transaction_rid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transaction"
            
        }
        response_data = self._api_client.call_api(
            method='POST',
            resource_path='/v1/datasets/{datasetRid}/transactions/{transactionRid}/commit',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def create_branch(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset on which to create the Branch.")],
        create_branch_request: CreateBranchRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Branch:
        """create_branch

        Creates a branch on an existing dataset. A branch may optionally point to a (committed) transaction.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-write`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset on which to create the Branch. (required)
        :type dataset_rid: str
        :param create_branch_request: (required)
        :type create_branch_request: CreateBranchRequest
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_branch_request is not None:
            _body_params = create_branch_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self._api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Branch"
            
        }
        response_data = self._api_client.call_api(
            method='POST',
            resource_path='/v1/datasets/{datasetRid}/branches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def create_dataset(
        self,
        create_dataset_request: CreateDatasetRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Dataset:
        """create_dataset

        Creates a new Dataset. A default branch - `master` for most enrollments - will be created on the Dataset.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-write`. 

        :param create_dataset_request: (required)
        :type create_dataset_request: CreateDatasetRequest
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_dataset_request is not None:
            _body_params = create_dataset_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self._api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dataset"
            
        }
        response_data = self._api_client.call_api(
            method='POST',
            resource_path='/v1/datasets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def create_transaction(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset on which to create the Transaction.")],
        create_transaction_request: CreateTransactionRequest,
        branch_id: Annotated[Optional[StrictStr], Field(description="The identifier (name) of the Branch on which to create the Transaction. Defaults to `master` for most enrollments. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Transaction:
        """create_transaction

        Creates a Transaction on a Branch of a Dataset.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-write`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset on which to create the Transaction. (required)
        :type dataset_rid: str
        :param create_transaction_request: (required)
        :type create_transaction_request: CreateTransactionRequest
        :param branch_id: The identifier (name) of the Branch on which to create the Transaction. Defaults to `master` for most enrollments. 
        :type branch_id: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        # process the query parameters
        if branch_id is not None:
            
            _query_params.append(('branchId', branch_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_transaction_request is not None:
            _body_params = create_transaction_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self._api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transaction"
            
        }
        response_data = self._api_client.call_api(
            method='POST',
            resource_path='/v1/datasets/{datasetRid}/transactions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def delete_branch(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset that contains the Branch.")],
        branch_id: Annotated[StrictStr, Field(description="The identifier (name) of the Branch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> None:
        """delete_branch

        Deletes the Branch with the given BranchId.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-write`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset that contains the Branch. (required)
        :type dataset_rid: str
        :param branch_id: The identifier (name) of the Branch. (required)
        :type branch_id: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        if branch_id is not None:
            _path_params['branchId'] = branch_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            
        }
        response_data = self._api_client.call_api(
            method='DELETE',
            resource_path='/v1/datasets/{datasetRid}/branches/{branchId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def delete_file(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset on which to delete the File.")],
        file_path: Annotated[StrictStr, Field(description="The File path within the Dataset.")],
        branch_id: Annotated[Optional[StrictStr], Field(description="The identifier (name) of the Branch on which to delete the File. Defaults to `master` for most enrollments.")] = None,
        transaction_rid: Annotated[Optional[StrictStr], Field(description="The Resource Identifier (RID) of the open delete Transaction on which to delete the File.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> None:
        """delete_file

        Deletes a File from a Dataset. By default the file is deleted in a new transaction on the default  branch - `master` for most enrollments. The file will still be visible on historical views.  #### Advanced Usage               See [Datasets Core Concepts](/docs/foundry/data-integration/datasets/) for details on using branches and transactions.  To **delete a File from a specific Branch** specify the Branch's identifier as `branchId`. A new delete Transaction  will be created and committed on this branch.  To **delete a File using a manually opened Transaction**, specify the Transaction's resource identifier  as `transactionRid`. The transaction must be of type `DELETE`. This is useful for deleting multiple files in a single transaction. See [createTransaction](/docs/foundry/api/datasets-resources/transactions/create-transaction/) to  open a transaction.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-write`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset on which to delete the File. (required)
        :type dataset_rid: str
        :param file_path: The File path within the Dataset. (required)
        :type file_path: str
        :param branch_id: The identifier (name) of the Branch on which to delete the File. Defaults to `master` for most enrollments.
        :type branch_id: str
        :param transaction_rid: The Resource Identifier (RID) of the open delete Transaction on which to delete the File.
        :type transaction_rid: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        if file_path is not None:
            _path_params['filePath'] = file_path
        # process the query parameters
        if branch_id is not None:
            
            _query_params.append(('branchId', branch_id))
            
        if transaction_rid is not None:
            
            _query_params.append(('transactionRid', transaction_rid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            
        }
        response_data = self._api_client.call_api(
            method='DELETE',
            resource_path='/v1/datasets/{datasetRid}/files/{filePath}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def delete_schema(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The RID of the Dataset on which to delete the schema. ")],
        branch_id: Annotated[Optional[StrictStr], Field(description="The ID of the Branch on which to delete the schema. ")] = None,
        transaction_rid: Annotated[Optional[StrictStr], Field(description="The RID of the Transaction on which to delete the schema. ")] = None,
        preview: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> None:
        """delete_schema

        Deletes the Schema from a Dataset and Branch. 

        :param dataset_rid: The RID of the Dataset on which to delete the schema.  (required)
        :type dataset_rid: str
        :param branch_id: The ID of the Branch on which to delete the schema. 
        :type branch_id: str
        :param transaction_rid: The RID of the Transaction on which to delete the schema. 
        :type transaction_rid: str
        :param preview:
        :type preview: bool
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        # process the query parameters
        if branch_id is not None:
            
            _query_params.append(('branchId', branch_id))
            
        if transaction_rid is not None:
            
            _query_params.append(('transactionRid', transaction_rid))
            
        if preview is not None:
            
            _query_params.append(('preview', preview))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            
        }
        response_data = self._api_client.call_api(
            method='DELETE',
            resource_path='/v1/datasets/{datasetRid}/schema',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def get_branch(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset that contains the Branch.")],
        branch_id: Annotated[StrictStr, Field(description="The identifier (name) of the Branch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Branch:
        """get_branch

        Get a Branch of a Dataset.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-read`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset that contains the Branch. (required)
        :type dataset_rid: str
        :param branch_id: The identifier (name) of the Branch. (required)
        :type branch_id: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        if branch_id is not None:
            _path_params['branchId'] = branch_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Branch"
            
        }
        response_data = self._api_client.call_api(
            method='GET',
            resource_path='/v1/datasets/{datasetRid}/branches/{branchId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def get_dataset(
        self,
        dataset_rid: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Dataset:
        """get_dataset

        Gets the Dataset with the given DatasetRid.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-read`. 

        :param dataset_rid: (required)
        :type dataset_rid: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dataset"
            
        }
        response_data = self._api_client.call_api(
            method='GET',
            resource_path='/v1/datasets/{datasetRid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def get_file_content(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset that contains the File.")],
        file_path: Annotated[StrictStr, Field(description="The File's path within the Dataset.")],
        branch_id: Annotated[Optional[StrictStr], Field(description="The identifier (name) of the Branch that contains the File. Defaults to `master` for most enrollments.")] = None,
        start_transaction_rid: Annotated[Optional[StrictStr], Field(description="The Resource Identifier (RID) of the start Transaction.")] = None,
        end_transaction_rid: Annotated[Optional[StrictStr], Field(description="The Resource Identifier (RID) of the end Transaction.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> bytearray:
        """get_file_content

        Gets the content of a File contained in a Dataset. By default this retrieves the file's content from the latest view of the default branch - `master` for most enrollments.  #### Advanced Usage  See [Datasets Core Concepts](/docs/foundry/data-integration/datasets/) for details on using branches and transactions.   To **get a file's content from a specific Branch** specify the Branch's identifier as `branchId`. This will  retrieve the content for the most recent version of the file since the latest snapshot transaction, or the earliest ancestor transaction of the branch if there are no snapshot transactions.  To **get a file's content from the resolved view of a transaction** specify the Transaction's resource identifier as `endTransactionRid`. This will retrieve the content for the most recent version of the file since the latest snapshot transaction, or the earliest ancestor transaction if there are no snapshot transactions.  To **get a file's content from the resolved view of a range of transactions** specify the the start transaction's resource identifier as `startTransactionRid` and the end transaction's resource identifier as `endTransactionRid`. This will retrieve the content for the most recent version of the file since the `startTransactionRid` up to the  `endTransactionRid`. Note that an intermediate snapshot transaction will remove all files from the view. Behavior is undefined when the start and end transactions do not belong to the same root-to-leaf path.  To **get a file's content from a specific transaction** specify the Transaction's resource identifier as both the  `startTransactionRid` and `endTransactionRid`.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-read`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset that contains the File. (required)
        :type dataset_rid: str
        :param file_path: The File's path within the Dataset. (required)
        :type file_path: str
        :param branch_id: The identifier (name) of the Branch that contains the File. Defaults to `master` for most enrollments.
        :type branch_id: str
        :param start_transaction_rid: The Resource Identifier (RID) of the start Transaction.
        :type start_transaction_rid: str
        :param end_transaction_rid: The Resource Identifier (RID) of the end Transaction.
        :type end_transaction_rid: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        if file_path is not None:
            _path_params['filePath'] = file_path
        # process the query parameters
        if branch_id is not None:
            
            _query_params.append(('branchId', branch_id))
            
        if start_transaction_rid is not None:
            
            _query_params.append(('startTransactionRid', start_transaction_rid))
            
        if end_transaction_rid is not None:
            
            _query_params.append(('endTransactionRid', end_transaction_rid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray"
            
        }
        response_data = self._api_client.call_api(
            method='GET',
            resource_path='/v1/datasets/{datasetRid}/files/{filePath}/content',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def get_file_metadata(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset that contains the File.")],
        file_path: Annotated[StrictStr, Field(description="The File's path within the Dataset.")],
        branch_id: Annotated[Optional[StrictStr], Field(description="The identifier (name) of the Branch that contains the File. Defaults to `master` for most enrollments.")] = None,
        start_transaction_rid: Annotated[Optional[StrictStr], Field(description="The Resource Identifier (RID) of the start Transaction.")] = None,
        end_transaction_rid: Annotated[Optional[StrictStr], Field(description="The Resource Identifier (RID) of the end Transaction.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> File:
        """get_file_metadata

        Gets metadata about a File contained in a Dataset. By default this retrieves the file's metadata from the latest view of the default branch - `master` for most enrollments.  #### Advanced Usage  See [Datasets Core Concepts](/docs/foundry/data-integration/datasets/) for details on using branches and transactions.   To **get a file's metadata from a specific Branch** specify the Branch's identifier as `branchId`. This will  retrieve metadata for the most recent version of the file since the latest snapshot transaction, or the earliest ancestor transaction of the branch if there are no snapshot transactions.  To **get a file's metadata from the resolved view of a transaction** specify the Transaction's resource identifier as `endTransactionRid`. This will retrieve metadata for the most recent version of the file since the latest snapshot transaction, or the earliest ancestor transaction if there are no snapshot transactions.  To **get a file's metadata from the resolved view of a range of transactions** specify the the start transaction's resource identifier as `startTransactionRid` and the end transaction's resource identifier as `endTransactionRid`. This will retrieve metadata for the most recent version of the file since the `startTransactionRid` up to the  `endTransactionRid`. Behavior is undefined when the start and end transactions do not belong to the same root-to-leaf path.  To **get a file's metadata from a specific transaction** specify the Transaction's resource identifier as both the  `startTransactionRid` and `endTransactionRid`.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-read`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset that contains the File. (required)
        :type dataset_rid: str
        :param file_path: The File's path within the Dataset. (required)
        :type file_path: str
        :param branch_id: The identifier (name) of the Branch that contains the File. Defaults to `master` for most enrollments.
        :type branch_id: str
        :param start_transaction_rid: The Resource Identifier (RID) of the start Transaction.
        :type start_transaction_rid: str
        :param end_transaction_rid: The Resource Identifier (RID) of the end Transaction.
        :type end_transaction_rid: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        if file_path is not None:
            _path_params['filePath'] = file_path
        # process the query parameters
        if branch_id is not None:
            
            _query_params.append(('branchId', branch_id))
            
        if start_transaction_rid is not None:
            
            _query_params.append(('startTransactionRid', start_transaction_rid))
            
        if end_transaction_rid is not None:
            
            _query_params.append(('endTransactionRid', end_transaction_rid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File"
            
        }
        response_data = self._api_client.call_api(
            method='GET',
            resource_path='/v1/datasets/{datasetRid}/files/{filePath}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def get_schema(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The RID of the Dataset. ")],
        branch_id: Annotated[Optional[StrictStr], Field(description="The ID of the Branch. ")] = None,
        transaction_rid: Annotated[Optional[StrictStr], Field(description="The TransactionRid that contains the Schema. ")] = None,
        preview: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> object:
        """get_schema

        Retrieves the Schema for a Dataset and Branch, if it exists. 

        :param dataset_rid: The RID of the Dataset.  (required)
        :type dataset_rid: str
        :param branch_id: The ID of the Branch. 
        :type branch_id: str
        :param transaction_rid: The TransactionRid that contains the Schema. 
        :type transaction_rid: str
        :param preview:
        :type preview: bool
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        # process the query parameters
        if branch_id is not None:
            
            _query_params.append(('branchId', branch_id))
            
        if transaction_rid is not None:
            
            _query_params.append(('transactionRid', transaction_rid))
            
        if preview is not None:
            
            _query_params.append(('preview', preview))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '204': None
            
        }
        response_data = self._api_client.call_api(
            method='GET',
            resource_path='/v1/datasets/{datasetRid}/schema',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def get_transaction(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset that contains the Transaction.")],
        transaction_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Transaction.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Transaction:
        """get_transaction

        Gets a Transaction of a Dataset.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-read`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset that contains the Transaction. (required)
        :type dataset_rid: str
        :param transaction_rid: The Resource Identifier (RID) of the Transaction. (required)
        :type transaction_rid: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        if transaction_rid is not None:
            _path_params['transactionRid'] = transaction_rid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transaction"
            
        }
        response_data = self._api_client.call_api(
            method='GET',
            resource_path='/v1/datasets/{datasetRid}/transactions/{transactionRid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def list_branches(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset on which to list Branches.")],
        page_size: Annotated[Optional[StrictInt], Field(description="The desired size of the page to be returned. Defaults to 1,000. See [page sizes](/docs/foundry/api/general/overview/paging/#page-sizes) for details. ")] = None,
        page_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListBranchesResponse:
        """list_branches

        Lists the Branches of a Dataset.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-read`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset on which to list Branches. (required)
        :type dataset_rid: str
        :param page_size: The desired size of the page to be returned. Defaults to 1,000. See [page sizes](/docs/foundry/api/general/overview/paging/#page-sizes) for details. 
        :type page_size: int
        :param page_token:
        :type page_token: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        # process the query parameters
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListBranchesResponse"
            
        }
        response_data = self._api_client.call_api(
            method='GET',
            resource_path='/v1/datasets/{datasetRid}/branches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def list_files(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset on which to list Files.")],
        branch_id: Annotated[Optional[StrictStr], Field(description="The identifier (name) of the Branch on which to list Files. Defaults to `master` for most enrollments.")] = None,
        start_transaction_rid: Annotated[Optional[StrictStr], Field(description="The Resource Identifier (RID) of the start Transaction.")] = None,
        end_transaction_rid: Annotated[Optional[StrictStr], Field(description="The Resource Identifier (RID) of the end Transaction.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="The desired size of the page to be returned. Defaults to 1,000. See [page sizes](/docs/foundry/api/general/overview/paging/#page-sizes) for details. ")] = None,
        page_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListFilesResponse:
        """list_files

        Lists Files contained in a Dataset. By default files are listed on the latest view of the default  branch - `master` for most enrollments.  #### Advanced Usage  See [Datasets Core Concepts](/docs/foundry/data-integration/datasets/) for details on using branches and transactions.  To **list files on a specific Branch** specify the Branch's identifier as `branchId`. This will include the most recent version of all files since the latest snapshot transaction, or the earliest ancestor transaction of the  branch if there are no snapshot transactions.  To **list files on the resolved view of a transaction** specify the Transaction's resource identifier as `endTransactionRid`. This will include the most recent version of all files since the latest snapshot transaction, or the earliest ancestor transaction if there are no snapshot transactions.  To **list files on the resolved view of a range of transactions** specify the the start transaction's resource identifier as `startTransactionRid` and the end transaction's resource identifier as `endTransactionRid`. This will include the most recent version of all files since the `startTransactionRid` up to the `endTransactionRid`. Note that an intermediate snapshot transaction will remove all files from the view. Behavior is undefined when  the start and end transactions do not belong to the same root-to-leaf path.  To **list files on a specific transaction** specify the Transaction's resource identifier as both the  `startTransactionRid` and `endTransactionRid`. This will include only files that were modified as part of that Transaction.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-read`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset on which to list Files. (required)
        :type dataset_rid: str
        :param branch_id: The identifier (name) of the Branch on which to list Files. Defaults to `master` for most enrollments.
        :type branch_id: str
        :param start_transaction_rid: The Resource Identifier (RID) of the start Transaction.
        :type start_transaction_rid: str
        :param end_transaction_rid: The Resource Identifier (RID) of the end Transaction.
        :type end_transaction_rid: str
        :param page_size: The desired size of the page to be returned. Defaults to 1,000. See [page sizes](/docs/foundry/api/general/overview/paging/#page-sizes) for details. 
        :type page_size: int
        :param page_token:
        :type page_token: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        # process the query parameters
        if branch_id is not None:
            
            _query_params.append(('branchId', branch_id))
            
        if start_transaction_rid is not None:
            
            _query_params.append(('startTransactionRid', start_transaction_rid))
            
        if end_transaction_rid is not None:
            
            _query_params.append(('endTransactionRid', end_transaction_rid))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListFilesResponse"
            
        }
        response_data = self._api_client.call_api(
            method='GET',
            resource_path='/v1/datasets/{datasetRid}/files',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def put_schema(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The RID of the Dataset on which to put the Schema. ")],
        body: Dict[str, Any],
        branch_id: Annotated[Optional[StrictStr], Field(description="The ID of the Branch on which to put the Schema. ")] = None,
        preview: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> None:
        """put_schema

        Puts a Schema on an existing Dataset and Branch. 

        :param dataset_rid: The RID of the Dataset on which to put the Schema.  (required)
        :type dataset_rid: str
        :param body: (required)
        :type body: object
        :param branch_id: The ID of the Branch on which to put the Schema. 
        :type branch_id: str
        :param preview:
        :type preview: bool
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        # process the query parameters
        if branch_id is not None:
            
            _query_params.append(('branchId', branch_id))
            
        if preview is not None:
            
            _query_params.append(('preview', preview))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Content-Type`
        _default_content_type = (
            self._api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            
        }
        response_data = self._api_client.call_api(
            method='PUT',
            resource_path='/v1/datasets/{datasetRid}/schema',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def read_table(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The RID of the Dataset. ")],
        format: Annotated[TableExportFormat, Field(description="The export format. Must be `ARROW` or `CSV`. ")],
        branch_id: Annotated[Optional[StrictStr], Field(description="The identifier (name) of the Branch.")] = None,
        start_transaction_rid: Annotated[Optional[StrictStr], Field(description="The Resource Identifier (RID) of the start Transaction.")] = None,
        end_transaction_rid: Annotated[Optional[StrictStr], Field(description="The Resource Identifier (RID) of the end Transaction.")] = None,
        columns: Annotated[Optional[List[StrictStr]], Field(description="A subset of the dataset columns to include in the result. Defaults to all columns. ")] = None,
        row_limit: Annotated[Optional[StrictInt], Field(description="A limit on the number of rows to return. Note that row ordering is non-deterministic. ")] = None,
        preview: Annotated[Optional[StrictBool], Field(description="A boolean flag that, when set to true, enables the use of beta features in preview mode. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> bytearray:
        """read_table

        :::callout{theme=warning title=Warning}   This endpoint is in preview and may be modified or removed at any time.   To use this endpoint, add `preview=true` to the request query parameters.   Furthermore, this endpoint currently does not support views (Virtual datasets composed of other datasets). :::  Gets the content of a dataset as a table in the specified format.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-read`. 

        :param dataset_rid: The RID of the Dataset.  (required)
        :type dataset_rid: str
        :param format: The export format. Must be `ARROW` or `CSV`.  (required)
        :type format: TableExportFormat
        :param branch_id: The identifier (name) of the Branch.
        :type branch_id: str
        :param start_transaction_rid: The Resource Identifier (RID) of the start Transaction.
        :type start_transaction_rid: str
        :param end_transaction_rid: The Resource Identifier (RID) of the end Transaction.
        :type end_transaction_rid: str
        :param columns: A subset of the dataset columns to include in the result. Defaults to all columns. 
        :type columns: List[str]
        :param row_limit: A limit on the number of rows to return. Note that row ordering is non-deterministic. 
        :type row_limit: int
        :param preview: A boolean flag that, when set to true, enables the use of beta features in preview mode. 
        :type preview: bool
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
            'columns': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        # process the query parameters
        if branch_id is not None:
            
            _query_params.append(('branchId', branch_id))
            
        if start_transaction_rid is not None:
            
            _query_params.append(('startTransactionRid', start_transaction_rid))
            
        if end_transaction_rid is not None:
            
            _query_params.append(('endTransactionRid', end_transaction_rid))
            
        if format is not None:
            
            _query_params.append(('format', format.value))
            
        if columns is not None:
            
            _query_params.append(('columns', columns))
            
        if row_limit is not None:
            
            _query_params.append(('rowLimit', row_limit))
            
        if preview is not None:
            
            _query_params.append(('preview', preview))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray"
            
        }
        response_data = self._api_client.call_api(
            method='GET',
            resource_path='/v1/datasets/{datasetRid}/readTable',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    @handle_unexpected
    def upload_file(
        self,
        dataset_rid: Annotated[StrictStr, Field(description="The Resource Identifier (RID) of the Dataset on which to upload the File.")],
        file_path: Annotated[StrictStr, Field(description="The File's path within the Dataset.")],
        body: Union[StrictBytes, StrictStr],
        branch_id: Annotated[Optional[StrictStr], Field(description="The identifier (name) of the Branch on which to upload the File. Defaults to `master` for most enrollments.")] = None,
        transaction_type: Annotated[Optional[TransactionType], Field(description="The type of the Transaction to create when using branchId. Defaults to `UPDATE`.")] = None,
        transaction_rid: Annotated[Optional[StrictStr], Field(description="The Resource Identifier (RID) of the open Transaction on which to upload the File.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> File:
        """upload_file

        Uploads a File to an existing Dataset. The body of the request must contain the binary content of the file and the `Content-Type` header must be `application/octet-stream`.  By default the file is uploaded to a new transaction on the default branch - `master` for most enrollments. If the file already exists only the most recent version will be visible in the updated view.  #### Advanced Usage  See [Datasets Core Concepts](/docs/foundry/data-integration/datasets/) for details on using branches and transactions.   To **upload a file to a specific Branch** specify the Branch's identifier as `branchId`. A new transaction will  be created and committed on this branch. By default the TransactionType will be `UPDATE`, to override this default specify `transactionType` in addition to `branchId`.  See [createBranch](/docs/foundry/api/datasets-resources/branches/create-branch/) to create a custom branch.  To **upload a file on a manually opened transaction** specify the Transaction's resource identifier as `transactionRid`. This is useful for uploading multiple files in a single transaction.  See [createTransaction](/docs/foundry/api/datasets-resources/transactions/create-transaction/) to open a transaction.  Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:datasets-write`. 

        :param dataset_rid: The Resource Identifier (RID) of the Dataset on which to upload the File. (required)
        :type dataset_rid: str
        :param file_path: The File's path within the Dataset. (required)
        :type file_path: str
        :param body: (required)
        :type body: bytearray
        :param branch_id: The identifier (name) of the Branch on which to upload the File. Defaults to `master` for most enrollments.
        :type branch_id: str
        :param transaction_type: The type of the Transaction to create when using branchId. Defaults to `UPDATE`.
        :type transaction_type: TransactionType
        :param transaction_rid: The Resource Identifier (RID) of the open Transaction on which to upload the File.
        :type transaction_rid: str
        :param _request_timeout: timeout setting for this request in seconds. If
                                 one number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, Any]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Any = None

        # process the path parameters
        if dataset_rid is not None:
            _path_params['datasetRid'] = dataset_rid
        # process the query parameters
        if file_path is not None:
            
            _query_params.append(('filePath', file_path))
            
        if branch_id is not None:
            
            _query_params.append(('branchId', branch_id))
            
        if transaction_type is not None:
            
            _query_params.append(('transactionType', transaction_type.value))
            
        if transaction_rid is not None:
            
            _query_params.append(('transactionRid', transaction_rid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            # convert to byte array if the input is a file name (str)
            if isinstance(body, str):
                with io.open(body, "rb") as _fp:
                    _body_params = _fp.read()
            else:
                _body_params = body


        # set the HTTP header `Accept`
        _header_params['Accept'] = self._api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File"
            
        }
        response_data = self._api_client.call_api(
            method='POST',
            resource_path='/v1/datasets/{datasetRid}/files:upload',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self._api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

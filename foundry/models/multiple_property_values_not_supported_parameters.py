#  Copyright 2024 Palantir Technologies, Inc.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# coding: utf-8

"""
    Palantir OpenAPI

    The Palantir REST API. Please see https://www.palantir.com/docs for more details.

    The version of the OpenAPI document: 1.738.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import json


from typing import Any, ClassVar, Dict, List
from typing import Set
from pydantic import BaseModel, StrictStr
from pydantic import Field
from typing_extensions import Self

class MultiplePropertyValuesNotSupportedParameters(BaseModel):
    """
    MultiplePropertyValuesNotSupportedParameters
    """ # noqa: E501
    var_property: StrictStr = Field(description="The name of the property in the API. To find the API name for your property, use the `Get object type` endpoint or check the **Ontology Manager**. ", alias="property")
    property_filter: StrictStr = Field(description="Represents a filter used on properties.  Endpoints that accept this supports optional parameters that have the form: `properties.{propertyApiName}.{propertyFilter}={propertyValueEscapedString}` to filter the returned objects. For instance, you may use `properties.firstName.eq=John` to find objects that contain a property called \"firstName\" that has the exact value of \"John\".  The following are a list of supported property filters:  - `properties.{propertyApiName}.contains` - supported on arrays and can be used to filter array properties   that have at least one of the provided values. If multiple query parameters are provided, then objects   that have any of the given values for the specified property will be matched. - `properties.{propertyApiName}.eq` - used to filter objects that have the exact value for the provided   property. If multiple query parameters are provided, then objects that have any of the given values   will be matched. For instance, if the user provides a request by doing   `?properties.firstName.eq=John&properties.firstName.eq=Anna`, then objects that have a firstName property   of either John or Anna will be matched. This filter is supported on all property types except Arrays. - `properties.{propertyApiName}.neq` - used to filter objects that do not have the provided property values.   Similar to the `eq` filter, if multiple values are provided, then objects that have any of the given values   will be excluded from the result. - `properties.{propertyApiName}.lt`, `properties.{propertyApiName}.lte`, `properties.{propertyApiName}.gt`   `properties.{propertyApiName}.gte` - represent less than, less than or equal to, greater than, and greater   than or equal to respectively. These are supported on date, timestamp, byte, integer, long, double, decimal. - `properties.{propertyApiName}.isNull` - used to filter objects where the provided property is (or is not) null.   This filter is supported on all property types. ", alias="propertyFilter")
    __properties: ClassVar[Set[str]] = set(("property", "propertyFilter"))

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "extra": "forbid"
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str, *, allow_extra=False) -> Self:
        """Create an instance of MultiplePropertyValuesNotSupportedParameters from a JSON string"""
        return cls.from_dict(json.loads(json_str), allow_extra=allow_extra)

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict, *, allow_extra=False) -> Self:
        """Create an instance of AsyncActionOperation from a dict"""
        # If allowing extra properties and the given object is a dict,
        # then remove any properties in the dict that aren't present
        # in the model properties list
        # We need to do this since the model config forbids additional properties
        # and this cannot be changed at runtime
        if (
            allow_extra and
            isinstance(obj, dict) and
            any(key not in cls.__properties for key in obj)
        ):
            obj = {key: value for key, value in obj.items() if key in cls.__properties}

        return cls.model_validate(obj)



#  Copyright 2024 Palantir Technologies, Inc.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# coding: utf-8

"""
    Palantir OpenAPI

    The Palantir REST API. Please see https://www.palantir.com/docs for more details.

    The version of the OpenAPI document: 1.738.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import json


from typing import Any, ClassVar, Dict, List, Optional
from typing import Set
from pydantic import BaseModel
from pydantic import Field
from foundry.models.action_type_v2 import ActionTypeV2
from foundry.models.object_type_with_link import ObjectTypeWithLink
from foundry.models.ontology_v2 import OntologyV2
from foundry.models.query_type_v2 import QueryTypeV2
from typing_extensions import Self


class OntologyFullMetadata(BaseModel):
    """
    OntologyFullMetadata
    """  # noqa: E501

    action_types: Optional[Dict[str, ActionTypeV2]] = Field(default=None, alias="actionTypes")
    object_types: Optional[Dict[str, ObjectTypeWithLink]] = Field(default=None, alias="objectTypes")
    ontology: OntologyV2
    query_types: Optional[Dict[str, QueryTypeV2]] = Field(default=None, alias="queryTypes")
    __properties: ClassVar[Set[str]] = set(("actionTypes", "objectTypes", "ontology", "queryTypes"))

    model_config = {"populate_by_name": True, "validate_assignment": True, "extra": "forbid"}

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str, *, allow_extra=False) -> Self:
        """Create an instance of OntologyFullMetadata from a JSON string"""
        return cls.from_dict(json.loads(json_str), allow_extra=allow_extra)

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={},
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in action_types (dict)
        _field_dict = {}
        if self.action_types:
            for _key in self.action_types:
                if self.action_types[_key]:
                    _field_dict[_key] = self.action_types[_key].to_dict()
            _dict["actionTypes"] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in object_types (dict)
        _field_dict = {}
        if self.object_types:
            for _key in self.object_types:
                if self.object_types[_key]:
                    _field_dict[_key] = self.object_types[_key].to_dict()
            _dict["objectTypes"] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of ontology
        if self.ontology:
            _dict["ontology"] = self.ontology.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in query_types (dict)
        _field_dict = {}
        if self.query_types:
            for _key in self.query_types:
                if self.query_types[_key]:
                    _field_dict[_key] = self.query_types[_key].to_dict()
            _dict["queryTypes"] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict, *, allow_extra=False) -> Self:
        """Create an instance of AsyncActionOperation from a dict"""
        # If allowing extra properties and the given object is a dict,
        # then remove any properties in the dict that aren't present
        # in the model properties list
        # We need to do this since the model config forbids additional properties
        # and this cannot be changed at runtime
        if (
            allow_extra
            and isinstance(obj, dict)
            and any(key not in cls.__properties for key in obj)
        ):
            obj = {key: value for key, value in obj.items() if key in cls.__properties}

        return cls.model_validate(obj)
